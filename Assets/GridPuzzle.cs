//------------------------------------------------------------------------------
// <auto-generated>
//     O código foi gerado por uma ferramenta.
//     Versão de Tempo de Execução:4.0.30319.34014
//
//     As alterações ao arquivo poderão causar comportamento incorreto e serão perdidas se
//     o código for gerado novamente.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using UnityEngine;
using System.Collections.Generic;
namespace AssemblyCSharp
{
	public class GridPuzzle : MonoBehaviour
	{
			public String nomeTileQueFoiClicado; //qd alguem clica num tile, esse nome muda
			static Tile[] tiles; //diz quais as acoes a serem executadas e em que ordem
				public GridPuzzle()
				{
				}
			
				public void alguemClicouNumTile(String nomeTile)
				{
					if (nomeTileQueFoiClicado.Length > 0) 
					{
						//alguem ja havia clicado num tile antes. Vamos trocar eles de posicao. Primeiro passo: Achar
						Tile umTile = null;
						Tile outroTile = null;
						int posicaoUmTile = -1;
						int posicaoOutroTile = -1;

						for(int i = 0; i < tiles.Length; i++)
						{
							String nome = tiles[i].getNome();
							if(nome.CompareTo(nomeTile) == 0 || nome.CompareTo(nomeTileQueFoiClicado) == 0)
							{
								if(umTile == null)
								{
									umTile = tiles[i];
									posicaoUmTile = i;
								}
								else
								{
									outroTile = tiles[i];
									posicaoOutroTile = i;
								}
							}
						}

						//agora vamos trocar os tiles de posicao graficamente
						object[] parametros = new object[2];
						parametros[0] = tiles[posicaoUmTile];
						parametros[1] = tiles[posicaoOutroTile];
						//StartCoroutine(trocarPosicaoDosTiles(tiles[posicaoUmTile], tiles[posicaoOutroTile]));
						trocarPosicaoDosTiles(tiles[posicaoUmTile], tiles[posicaoOutroTile]);
						//agora vamos mudar os tiles de posicao criando um novo array com os tiles nas posicoes trocadas
						
						Tile[] newTiles = new Tile[tiles.Length];
						for(int j = 0; j < newTiles.Length; j++)
						{
							if(j == posicaoUmTile)
							{
								newTiles[j] = outroTile;
							}
							else if(j == posicaoOutroTile)
							{
								newTiles[j] = umTile;
							}
							else
							{
								newTiles[j] = tiles[j];
							}
						}

						//agora o valor desse novo array vai para o velho
						tiles = newTiles;

						//nenhum tile deve ter sido clicado anteriormente
						nomeTileQueFoiClicado = "";

					} 
					else 
					{
						nomeTileQueFoiClicado = nomeTile;
					}

				}
				
				public static void trocarPosicaoDosTiles(Tile t1, Tile t2)
				{
					//Debug.Log ("t1:" + t1.getAcao() + ";" + "t2:" + t2.getAcao());
					Vector3 temp1 = GameObject.Find(t1.getNome()).transform.position;
					Vector3 temp2 = GameObject.Find(t2.getNome()).transform.position;
					
					GameObject g1 = GameObject.Find(t1.getNome());
					GameObject g2 = GameObject.Find(t2.getNome());
				
					Vector3 temp = new Vector3();
					temp.Set(g1.transform.position.x, g1.transform.position.y, g1.transform.position.z);
					g1.transform.position = g2.transform.position;
					g2.transform.position = temp;
				//PROCURAR COMO FAZER COROTINA  FAZER OS BLOCOS MUDAREM GRADUATIVAMENTE DE POSICAO		

					/*while(g2.transform.position != temp1 && g1.transform.position != temp2)
					{
						if (temp1.x > temp2.x)
						{
					g1.transform.Translate(Convert.ToSingle(-0.108),0,0);
					g2.transform.Translate(Convert.ToSingle(0.108),0,0);
							//g1.transform.position.x --;
							//g2.transform.position.x ++;
						}
						else if (temp1.x < temp2.x)
						{
					g1.transform.Translate(Convert.ToSingle(0.108),0,0);
					g2.transform.Translate(Convert.ToSingle(-0.108),0,0);
							//g1.transform.position.x ++;
							//g2.transform.position.x --;
						}
						
						if (temp1.y > temp2.y)
						{
							g1.transform.Translate(0,-1,0);
							g2.transform.Translate(0,1,0);
							//g1.transform.position.y --;
							//g2.transform.position.y ++;
						}
						else if (temp1.y < temp2.y)
						{
							g1.transform.Translate(0,1,0);
							g2.transform.Translate(0,-1,0);
							//g1.transform.position.y ++;
							//g2.transform.position.y --;
						}
					}*/
					
				}
				
				public String[] pegarOrdemDasAcoes()
				{
					String[] acoes = new String[tiles.Length];
					int percorredorAcoes = 0;
						for (int i = 0; i < tiles.Length; i++) 
						{
							Tile umTile = tiles[i];
							acoes[percorredorAcoes] = umTile.getAcao();
							percorredorAcoes = percorredorAcoes + 1;
						}
					return acoes;
				}
		// Use this for initialization
		void Start () 
		{
			String nomeTiles = "tile";
			int quantosTilesExistemNaCena = 0;
			//primeiro vou saber quantos tiles existem na cena para saber o tamanho exato do meu array de tiles
			for (int i = 1; i < 10; i++)  
			{
				//sao 9 tiles no total
				nomeTiles = nomeTiles + i;
				GameObject gameObjectDoTile = GameObject.Find(nomeTiles);
				if(gameObjectDoTile != null)
				{
					//o tile existe na cena
					quantosTilesExistemNaCena = quantosTilesExistemNaCena + 1;
					nomeTiles = nomeTiles.Substring(0, nomeTiles.Length - 1); //tirei a ultima letra dessa string. Ficou so "tile"
				}
				else
				{
					//n tem mais nenhum tile na cena. Parar de procurar.
					break;
				}
			}

			//agora eu sei o tamanho ideal para o arrannjo tiles
			tiles = new Tile[quantosTilesExistemNaCena];

			//agora vou povoar esse arranjo
			nomeTiles = "tile";
			for (int i = 1; i < 10; i++)  
			{
				//vou pegar cada um dos 9 tiles, se houverem
				//vou fazer uma busca pelo objeto de nome tile1, depois tile2 e assim vai. Se ele n existir, nao entra no arranjo tiles
				nomeTiles = nomeTiles + i;
				GameObject gameObjectDoTile = GameObject.Find(nomeTiles);
				if(gameObjectDoTile != null)
				{
					//o tile existe na cena
					Tile umTile = (Tile) gameObjectDoTile.GetComponent<Tile>();
					umTile.setarNome(nomeTiles);
					String acaoTile = gameObjectDoTile.tag; //a cao de cada tile deve estar setada como tag dele
					umTile.setarAcao(acaoTile);
					tiles[i - 1] = umTile; //povoei o arranjo tiles

					nomeTiles = nomeTiles.Substring(0, nomeTiles.Length - 1); //tirei a ultima letra dessa string. Ficou so "tile"

				}
				else
				{
					//nao existem mais tiles na cena
					break;
				}
			}

			nomeTileQueFoiClicado = "";

		}
		
		
		void Update () {
		}
		void Awake() 
		{
			DontDestroyOnLoad(this);
		}

	}
}

